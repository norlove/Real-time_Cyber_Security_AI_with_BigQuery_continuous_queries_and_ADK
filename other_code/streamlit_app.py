"""
This Streamlit application serves as a web-based console for a Security Operations
Center (SOC) analyst. It provides a human-in-the-loop interface for a security
workflow orchestrated by a Vertex AI Agent (ADK).

The app polls a Google Cloud Storage (GCS) bucket for new escalation files
generated by the agent, displays the details of each alert, and allows the
analyst to submit their judgment (e.g., "False Positive" or "Genuine Threat").
The analyst's response is then written back to the GCS bucket for the agent
to retrieve and complete the workflow.
"""
import streamlit as st
import time
import json
import os
import re 
from google.cloud import storage
from google.api_core import exceptions
from streamlit_autorefresh import st_autorefresh

# --- UNIQUE PROJECT CONFIGURATION DETAILS BELOW ---
PROJECT_ID = "bigquery-demos-project"
ESCALATION_BUCKET_NAME = "cymbal-cyber-adk-escalations-bucket_bigquery-demos-project"
# --- UNIQUE PROJECT CONFIGURATION DETAILS ABOVE ---

# How often (in seconds) to poll GCS for new escalations.
ESCALATION_POLL_INTERVAL = 5 
# How long (in seconds) to display temporary notifications on screen.
NOTIFICATION_DURATION = 5

# --- Streamlit Page Config ---
st.set_page_config(page_title="SOC Analyst Console", layout="wide")
st.title("SOC Analyst Console")

# --- Session State Initialization ---
# Streamlit reruns the script from top to bottom on each interaction.
# We use st.session_state to store persistent information across these reruns.
# This avoids losing data like the list of alerts or the user's current selection.
if "escalations" not in st.session_state:
    st.session_state.escalations = []
if "selected_ticket_id" not in st.session_state:
    st.session_state.selected_ticket_id = None
if "alert_data" not in st.session_state:
    st.session_state.alert_data = None
if "last_escalation_poll" not in st.session_state:
    st.session_state.last_escalation_poll = 0
if "response_comment" not in st.session_state:
    st.session_state.response_comment = ""
if "decision_choice" not in st.session_state:
    st.session_state.decision_choice = "False Positive"
if "new_alert_timestamp" not in st.session_state:
    st.session_state.new_alert_timestamp = None
if "response_submitted_timestamp" not in st.session_state:
    st.session_state.response_submitted_timestamp = None
if "previous_escalation_ids" not in st.session_state:
    st.session_state.previous_escalation_ids = set()


# --- Helper and Callback Functions ---
@st.cache_resource
def get_gcp_clients():
    """
    Initializes and caches the GCP Storage client.
    Using @st.cache_resource ensures this expensive operation runs only once.
    """
    try:
        storage_client = storage.Client(project=PROJECT_ID)
        return storage_client
    except Exception as e:
        st.error(f"Failed to initialize GCP Storage client: {e}")
        return None

def fetch_escalations(storage_client, force_refresh=False):
    """
    Scans the GCS bucket for new escalation files generated by the agent.
    This function acts as the primary data source for the application.
    """
    now = time.time()
    if not force_refresh and (now - st.session_state.get("last_escalation_poll", 0) < ESCALATION_POLL_INTERVAL):
        return

    escalation_list = []
    try:
        bucket = storage_client.bucket(ESCALATION_BUCKET_NAME)
        blobs = bucket.list_blobs()
        current_ids = set()
        for blob in blobs:
            if blob.name.startswith("human_escalation_information_") and blob.name.endswith(".json"):
                try:
                    content = blob.download_as_text()
                    data = json.loads(content)
                    ticket_id = data.get("ticket_id", "Unknown ID")
                    escalation_list.append({"ticket_id": ticket_id, "blob_name": blob.name})
                    current_ids.add(ticket_id)
                except (json.JSONDecodeError, exceptions.NotFound) as e:
                    print(f"Could not process blob {blob.name}: {e}")

        if len(current_ids) > len(st.session_state.previous_escalation_ids):
             st.session_state.new_alert_timestamp = time.time()

        st.session_state.escalations = escalation_list
        st.session_state.previous_escalation_ids = current_ids
        st.session_state.last_escalation_poll = now

    except Exception as e:
        st.error(f"Error fetching escalations from GCS: {e}")
        st.session_state.last_escalation_poll = now

def select_ticket(ticket_id, blob_name):
    """
    This is an on_click callback function triggered when an analyst clicks an
    escalation button. It loads the full details for that ticket from GCS.
    """
    st.session_state.selected_ticket_id = ticket_id
    try:
        storage_client = get_gcp_clients()
        bucket = storage_client.bucket(ESCALATION_BUCKET_NAME)
        blob = bucket.blob(blob_name)
        alert_content = blob.download_as_text()
        st.session_state.alert_data = json.loads(alert_content)
        st.session_state.response_comment = ""
        st.session_state.decision_choice = "False Positive"
    except Exception as e:
        st.error(f"Failed to load alert {ticket_id}: {e}")
        st.session_state.selected_ticket_id = None

def submit_analyst_response():
    """
    This on_click callback is the final step in the UI workflow. It takes the
    analyst's decision, creates a response file, and uploads it to GCS for the
    ADK agent to find.
    """
    # Get the user's input from the session state.
    decision = st.session_state.decision_choice
    comment = st.session_state.response_comment

    try:
        storage_client = get_gcp_clients()
        bucket = storage_client.bucket(ESCALATION_BUCKET_NAME)
        
        ticket_id = st.session_state.alert_data.get("ticket_id")
        if not ticket_id:
            st.error("Cannot submit response: Ticket ID is missing.")
            return

        # Create the response filename using a convention the agent expects.
        response_filename = f"human_escalation_response_{ticket_id}.json"
        response_blob = bucket.blob(response_filename)
        
        # Construct the JSON payload for the response.
        response_payload = {
            "ticket_id": ticket_id,
            "human_decision": decision,
            "human_comment": comment,
            "timestamp": time.time()
        }
        # Upload the response file to GCS.
        response_blob.upload_from_string(json.dumps(response_payload, indent=2), content_type="application/json")

        st.session_state.response_submitted_timestamp = time.time()
        
        st.session_state.selected_ticket_id = None
        st.session_state.alert_data = None
        st.session_state.response_comment = ""
        
        fetch_escalations(storage_client, force_refresh=True)

    except Exception as e:
        st.error(f"Error submitting response: {e}")


# --- Main Application Logic ---
# Automatically refresh the entire page every 60 seconds to catch any stale data.
st_autorefresh(interval=60 * 1000, key="data_refresher")

storage_client = get_gcp_clients()
if not storage_client:
    st.stop()

fetch_escalations(storage_client)

# This block is a safety check. If a ticket is resolved in the background
# (i.e., its file is deleted), this code ensures we don't try to display stale data.
if st.session_state.get("selected_ticket_id"):
    valid_ticket_ids = {esc['ticket_id'] for esc in st.session_state.escalations}
    if st.session_state.selected_ticket_id not in valid_ticket_ids:
        st.session_state.selected_ticket_id = None
        st.session_state.alert_data = None
        st.session_state.response_comment = ""

# This block displays the "New Alert" notification for a few seconds.
if st.session_state.get("new_alert_timestamp"):
    if time.time() - st.session_state.new_alert_timestamp < NOTIFICATION_DURATION:
        st.toast("ðŸš¨ NEW ESCALATION ALERT! ðŸš¨", icon="âš ï¸")
        st.success("A new escalation alert has been received. Please review!", icon="ðŸ””")
    else:
        st.session_state.new_alert_timestamp = None

# This block displays the "Response Submitted" notification for a few seconds.
if st.session_state.get("response_submitted_timestamp"):
    if time.time() - st.session_state.response_submitted_timestamp < NOTIFICATION_DURATION:
        st.toast("Response submitted successfully.", icon="âœ…")
    else:
        st.session_state.response_submitted_timestamp = None


# --- UI Rendering ---
# Define the two-column layout for the console.
col1, col2 = st.columns([1, 2], gap="large")

# Left column: List of pending escalations.
with col1:
    st.subheader("Pending Escalations")
    escalation_placeholder = st.empty()

# Right column: Details of the selected escalation and the response form.
with col2:
    st.subheader("Alert Details & Response")
    details_placeholder = st.empty()

# Populate the left column.
with escalation_placeholder.container(border=True, height=850):
    if not st.session_state.escalations:
        st.info("No escalations are currently pending.")
    else:
        for esc in st.session_state.escalations:
            st.button(
                esc["ticket_id"],
                key=esc["ticket_id"],
                use_container_width=True,
                on_click=select_ticket,
                args=(esc["ticket_id"], esc["blob_name"])
            )

# Populate the right column.
with details_placeholder.container():
    if not st.session_state.selected_ticket_id:
        st.info("Select an escalation from the left to view details.")
    else:
        alert_info = st.session_state.alert_data
        if alert_info:
            context_text = alert_info.get('context_for_human', '')
            
            # Define a regex pattern to find the GCS signed URL
            url_pattern = re.compile(r'(https://storage\.googleapis\.com/[^\s\)]+)')
            url_match = url_pattern.search(context_text)

            if url_match:
                # If a URL is found, extract it
                found_url = url_match.group(1)
                # Create the markdown hyperlink with a clean name
                hyperlink = f"[Link to user desktop screenshot]({found_url})"
                # Replace the raw URL with the new hyperlink in the text
                context_text = context_text.replace(found_url, hyperlink)

            st.markdown("---")
            st.markdown("#### **Alert Details**")
            st.write(f"**Ticket ID:** `{alert_info.get('ticket_id', 'N/A')}`")
            st.markdown(f"**Reason for Escalation:** :warning: {alert_info.get('agent_reason_for_escalation', 'No reason provided.')}")
            st.markdown("---")

            st.markdown("##### **Agent's Summary**")
            st.markdown(context_text or '*No context provided.*', unsafe_allow_html=True)
            
            st.markdown("---")
            st.markdown("#### **Your Response**")
            
            st.radio(
                "Investigation Outcome:",
                ("False Positive", "Genuine Threat"),
                key="decision_choice",
                horizontal=True,
            )
            
            st.text_area(
                "Add a comment (optional):",
                height=150,
                key="response_comment" 
            )
            
            st.button(
                "Submit Response",
                type="primary",
                on_click=submit_analyst_response
            )
